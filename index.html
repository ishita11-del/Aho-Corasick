<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aho‚ÄìCorasick Algorithm Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: #0f172a;
    }
    .highlight {
      background-color: #fbbf24;
      border-radius: 4px;
      padding: 2px 4px;
      color: #000;
      font-weight: bold;
    }
  </style>
</head>
<body class="bg-slate-900 text-gray-100 font-sans">
  <header class="text-center py-6 bg-gradient-to-r from-blue-600 to-purple-600 text-white shadow-lg">
    <h1 class="text-3xl font-bold">Aho‚ÄìCorasick Algorithm Visualization</h1>
    <p class="text-sm mt-2">Compare Naive and Aho‚ÄìCorasick String Matching Approaches</p>
  </header>

  <main class="max-w-4xl mx-auto py-10 px-4">
    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2 text-blue-400">Enter Input</h2>
      <p class="text-gray-400 mb-2">Enter your text and patterns (comma-separated):</p>
      <textarea id="textInput" class="w-full p-3 border border-gray-700 rounded mb-3 bg-slate-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none" rows="4" placeholder="Enter text here...">she sells seashells by the seashore</textarea>
      <input id="patternsInput" class="w-full p-3 border border-gray-700 rounded mb-4 bg-slate-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="Enter patterns (e.g., he,she,his,hers)" value="she,sea,shells,shore" />

      <div class="flex gap-4">
        <button id="naiveBtn" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded shadow-lg transition">
          üîç Naive Search
        </button>
        <button id="ahoBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded shadow-lg transition">
          ‚ö° Aho‚ÄìCorasick Search
        </button>
      </div>
    </section>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2 text-purple-400">Output</h2>
      <div id="outputArea" class="p-4 border border-gray-700 rounded bg-slate-800 shadow-lg min-h-[100px] text-lg"></div>
      <p id="timeDisplay" class="mt-3 text-gray-300 font-medium"></p>
      <p id="matchCount" class="mt-1 text-gray-400 text-sm"></p>
    </section>

    <section class="mb-8">
      <h2 class="text-2xl font-semibold mb-2 text-green-400">Algorithm Explanation</h2>
      <div class="bg-slate-800 p-4 rounded border border-gray-700">
        <p class="text-gray-300 mb-3">
          <strong class="text-green-400">Aho‚ÄìCorasick</strong> efficiently finds multiple patterns in a single pass by building a Trie of all patterns and creating failure links that allow the algorithm to skip redundant comparisons.
        </p>
        <p class="text-gray-300 mb-3">
          <strong class="text-blue-400">Time Complexity:</strong> O(n + m + z) where n = text length, m = total pattern length, z = matches
        </p>
        <p class="text-gray-300">
          <strong class="text-purple-400">Applications:</strong> Spam filters, plagiarism detection, DNA pattern matching, search engines, intrusion detection systems.
        </p>
      </div>
    </section>

    <footer class="text-center py-4 border-t border-gray-700 mt-10 text-gray-500 text-sm">
      ¬© 2025 | Aho‚ÄìCorasick Visualization
    </footer>
  </main>

  <script>
    class AhoCorasick {
      constructor(patterns) {
        this.trie = { children: {}, output: [], fail: null };
        this.buildTrie(patterns);
        this.buildFailureLinks();
      }

      buildTrie(patterns) {
        for (const pattern of patterns) {
          let node = this.trie;
          for (const ch of pattern) {
            if (!node.children[ch]) {
              node.children[ch] = { children: {}, output: [], fail: null };
            }
            node = node.children[ch];
          }
          node.output.push(pattern);
        }
      }

      buildFailureLinks() {
        const queue = [];
        for (const ch in this.trie.children) {
          this.trie.children[ch].fail = this.trie;
          queue.push(this.trie.children[ch]);
        }

        while (queue.length > 0) {
          const current = queue.shift();
          for (const ch in current.children) {
            const child = current.children[ch];
            queue.push(child);

            let fail = current.fail;
            while (fail && !fail.children[ch]) {
              fail = fail.fail;
            }
            child.fail = fail ? fail.children[ch] : this.trie;
            child.output = child.output.concat(child.fail.output);
          }
        }
      }

      search(text) {
        const matches = [];
        let node = this.trie;

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          while (node && !node.children[ch]) {
            node = node.fail;
          }
          node = node ? node.children[ch] : this.trie;
          if (!node) node = this.trie;

          for (const pattern of node.output) {
            matches.push({
              start: i - pattern.length + 1,
              end: i + 1,
              pattern: pattern
            });
          }
        }

        return matches;
      }
    }

    function highlightText(text, matches) {
      if (!text || matches.length === 0) return text;
      
      let highlighted = '';
      let lastIndex = 0;

      const sortedMatches = matches.sort((a, b) => a.start - b.start);

      sortedMatches.forEach(match => {
        highlighted += text.slice(lastIndex, match.start);
        highlighted += `<span class="highlight">${text.slice(match.start, match.end)}</span>`;
        lastIndex = match.end;
      });

      highlighted += text.slice(lastIndex);
      return highlighted;
    }

    function naiveSearch(text, patterns) {
      if (!text || patterns.length === 0) {
        return { matches: [], time: 0 };
      }

      const matches = [];
      const startTime = performance.now();

      for (const pattern of patterns) {
        let index = text.indexOf(pattern);
        while (index !== -1) {
          matches.push({ 
            start: index, 
            end: index + pattern.length,
            pattern: pattern 
          });
          index = text.indexOf(pattern, index + 1);
        }
      }

      const endTime = performance.now();
      return { matches: matches.sort((a, b) => a.start - b.start), time: endTime - startTime };
    }

    function ahoCorasickSearch(text, patterns) {
      if (!text || patterns.length === 0) {
        return { matches: [], time: 0 };
      }

      const startTime = performance.now();
      const ac = new AhoCorasick(patterns);
      const matches = ac.search(text);
      const endTime = performance.now();

      return { matches, time: endTime - startTime };
    }

    document.getElementById('naiveBtn').addEventListener('click', () => {
      const text = document.getElementById('textInput').value;
      const patterns = document.getElementById('patternsInput').value
        .split(',')
        .map(p => p.trim())
        .filter(p => p);
      
      if (!text) {
        document.getElementById('outputArea').innerHTML = '<span class="text-red-400">Please enter some text!</span>';
        return;
      }
      if (patterns.length === 0) {
        document.getElementById('outputArea').innerHTML = '<span class="text-red-400">Please enter at least one pattern!</span>';
        return;
      }

      const { matches, time } = naiveSearch(text, patterns);
      document.getElementById('outputArea').innerHTML = highlightText(text, matches);
      document.getElementById('timeDisplay').textContent = `üîç Naive Search Time: ${time.toFixed(4)} ms`;
      document.getElementById('matchCount').textContent = `Found ${matches.length} match(es)`;
    });

    document.getElementById('ahoBtn').addEventListener('click', () => {
      const text = document.getElementById('textInput').value;
      const patterns = document.getElementById('patternsInput').value
        .split(',')
        .map(p => p.trim())
        .filter(p => p);
      
      if (!text) {
        document.getElementById('outputArea').innerHTML = '<span class="text-red-400">Please enter some text!</span>';
        return;
      }
      if (patterns.length === 0) {
        document.getElementById('outputArea').innerHTML = '<span class="text-red-400">Please enter at least one pattern!</span>';
        return;
      }

      const { matches, time } = ahoCorasickSearch(text, patterns);
      document.getElementById('outputArea').innerHTML = highlightText(text, matches);
      document.getElementById('timeDisplay').textContent = `‚ö° Aho‚ÄìCorasick Search Time: ${time.toFixed(4)} ms`;
      document.getElementById('matchCount').textContent = `Found ${matches.length} match(es)`;
    });
  </script>
</body>
</html>
